<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL数据分析]]></title>
    <url>%2F2020%2F04%2F03%2FMySQL%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] 本部分主要涉及到MySQL进行简单的计算。 第十章 创建计算字段为什么要创建计算字段呢？通常来讲，存储在数据库中的数据往往都不是应用程序所需要的，比如说我们想要获得每个月的收益值，那么就不需要从数据库中获取一个月当中每一天的收益，而只需要对当月数据进行求和即可，这样就可以最大程度地减轻访问数据库的压力。 计算字段是运行时在SELECT语句内创建的。 字段：基本与列的意思相同，经常互换使用，不过数据库一般称为列，而属于字段通常用在计算字段的连接上。 10.1 拼接操作例如：在vendors表中包含供应商名和位置信息，我们想要生成一个供应商的报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。我们需要一个拼接操作 在vendors表中有两个列，分别是vend_name和vend_country。 拼接(concatenate)将值连接到一起构成单个值 口令是Concat(在其他DBMS中，会用+或者||进行拼接) 12345678910111213SELECT Concat(vend_name,' (',vend_country,')') FROM vendorsORDER BY vend_name;+-----------------------------------------+| Concat(vend_name,' (',vend_country,')') |+-----------------------------------------+| ACME (USA) || Anvils R Us (USA) || Furball Inc. (USA) || Jet Set (England) || Jouets Et Ours (France) || LT Supplies (USA) |+-----------------------------------------+ RTrim是用来删除值右侧的所有空格（LTrim用来删除左侧所有的空格以及Trim删除两侧的空格） 12345678910111213SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country),')') FROM vendorsORDER BY vend_name;+-------------------------------------------------------+| Concat(RTrim(vend_name),' (',RTrim(vend_country),')') |+-------------------------------------------------------+| ACME (USA) || Anvils R Us (USA) || Furball Inc. (USA) || Jet Set (England) || Jouets Et Ours (France) || LT Supplies (USA) |+-------------------------------------------------------+ 上述操作，我们只是简单地看一眼当然没有什么问题，新值只是被计算出来了而已，并没有被实际命名，我们自然也就不能引用，于是我们要给他一个别名。 1234567891011121314SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country),')') AS vend_titleFROM vendorsORDER BY vend_name;+-------------------------+| vend_title |+-------------------------+| ACME (USA) || Anvils R Us (USA) || Furball Inc. (USA) || Jet Set (England) || Jouets Et Ours (France) || LT Supplies (USA) |+-------------------------+ 别名的另一个作用就是当列名不符合规范或者名字不好时，可以通过别名达到重新命名的结果。 10.2 执行算术计算123456789101112SELECT prod_id,quantity,item_priceFROM orderitemsWHERE order_num = 20005;+---------+----------+------------+| prod_id | quantity | item_price |+---------+----------+------------+| ANV01 | 10 | 5.99 || ANV02 | 3 | 9.99 || TNT2 | 5 | 10.00 || FB | 1 | 10.00 |+---------+----------+------------+ 我们首先获取orderitems表中的订单数量，物品价格。此时我们想要知道订单的总价是多少，即数量乘以单价。 123456789101112SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM orderitemsWHERE order_num = 20005;+---------+----------+------------+----------------+| prod_id | quantity | item_price | expanded_price |+---------+----------+------------+----------------+| ANV01 | 10 | 5.99 | 59.90 || ANV02 | 3 | 9.99 | 29.97 || TNT2 | 5 | 10.00 | 50.00 || FB | 1 | 10.00 | 10.00 |+---------+----------+------------+----------------+ 我们通过*得到了一个新的计算字段。四则运算都可以，圆括号用来区分优先顺序。 第十一章 使用数据处理函数本章介绍什么是函数，MySQL支持何种函数以及如何使用这些函数。 函数：function, 和其他程序语言一样，函数就是实现某个具体功能的代码块。 注意：函数的可移植性不好，所以往往在不同的DBMS之间差异很大，所以如果要使用函数的话们应该做好代码注释。 11.1 使用不同类型的函数函数主要包括以下几种类型： 用于处理文本串，如删除或填充值，转化为大写或小写； 数值运算函数，例如绝对值，指数，对数之类的； 处理日期和时间值的函数； 返回DBMS的特殊信息，比如用户登录信息，版本信息等系统函数。 11.1.1 文本处理函数上一节中，我们用到了RTrim和Concat函数，我们再来看几个, 将文本转化为大写； 1234567891011121314SELECT vend_name,Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name;+----------------+------------------+| vend_name | vend_name_upcase |+----------------+------------------+| ACME | ACME || Anvils R Us | ANVILS R US || Furball Inc. | FURBALL INC. || Jet Set | JET SET || Jouets Et Ours | JOUETS ET OURS || LT Supplies | LT SUPPLIES |+----------------+------------------+ Left(str,len): 返回串str左边长度为Len的字符串；(Right) 1234567SELECT Left("abc",2); /* 返回字符串ab */+---------------+| Left("abc",2) |+---------------+| ab |+---------------+ Length: 返回串的长度； Locate: 格式为LOCATE(substr,str), LOCATE(substr,str,pos)； 12SELECT LOCATE('bar', 'foobarbar'); -&gt; 4 -- 返回4，即第一次bar出现的位置 12SELECT LOCATE('xbar', 'foobar'); -&gt; 0 -- 返回0,是因为查不到 12SELECT LOCATE('bar', 'foobarbar', 5); -&gt; 7 -- 从第5个位置开始索引，找到第一个bar的起始位置 LTrim,RTrim,Upper,Lower. Soundex: 返回串的SOUNDEX值，使能够对串进行发音比较而不是字母比较。 12345678910111213141516171819202122232425SELECT cust_name,cust_contactFROM customersWHERE cust_contact = 'Y. Lie'; -&gt; Empty set -- 返回空集合，不会返回数据，这是因为名字写错了，应该是Y Lee SELECT cust_name,cust_contactFROM customersWHERE cust_contact = 'Y Lee'; -- 则会出现返回值+-------------+--------------+| cust_name | cust_contact |+-------------+--------------+| Coyote Inc. | Y Lee |+-------------+--------------+-- 为了避免这种情况，我们采用发音比较的方式SELECT cust_name,cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex('Y. Lie'); -- 此时返回Y Lee的记录，发音上比较相似+-------------+--------------+| cust_name | cust_contact |+-------------+--------------+| Coyote Inc. | Y Lee |+-------------+--------------+ SubString: 格式为下述之一，起到取子串的作用。 SUBSTRING(str,pos), SUBSTRING(str FROM pos), SUBSTRING(str,pos,len),SUBSTRING(str FROM pos FOR len) 11.1.2 日期和事件处理函数日期和时间采用相应的数据类型和特殊的格式存储。一般地，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取，统计和处理这些值，由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。 日期和时间函数有以下几类： 获取当前时间的信息，Now, CurDate(Current),CurTime; 获取某个日期的具体信息， Date，Time, Year, Month, Day, Hour, Minute, Second, DayOfWeek(星期几); 日期的添删运算AddDate, AddTime, DateDiff, Date_Add, Date_Format. 函数 用途 示例 输出 AddDate 增加日期（比给出日期变化多少） SELECT ADDDATE(‘2008-01-02’, INTERVAL 31DAY); SELECT ADDDATE(‘2008-01-02’, 31); 2008-02-02 AddTime 增加时间 CurDate 返回当前日期 SELECT CurDate(); 2020-04-03 CurTime 返回当前时间 SELECT CurTime(); 15:54:33 Date 返回日期部分 SELECT Date(‘2020-04-03 15:54:33’); 2020-04-03 DateDiff 日期之差 SELECT DATEDIFF(‘2007-12-31 23:59:59’,’2007-12-30’); 1 Date_Add 灵活的日期运算函数(可以加减小时分钟) SELECT DATE_ADD(‘2008-01-02’, INTERVAL 31 DAY); 2008-02-02 Date_Format 日期格式化 SELECT DATE_FORMAT(‘2009-10-04 22:23:00’, ‘%W %M %Y’); ‘Sunday October 2009’ Day 返回某个日期的天 SELECT Day(‘2020-04-03 15:54:33’); 3 DayOfWeek 返回某个日期是星期几 SELECT DAYOFWEEK(‘2020-04-03’); 6（星期天是第一天） Hour 返回某个日期的小时 SELECT Hour(‘2020-04-03 15:54:33’); 15 Minute 返回某个日期的分钟 SELECT Minute(‘2020-04-03 15:54:33’); 54 Month 返回某个日期的月份 SELECT Month(‘2020-04-03 15:54:33’); 4 Now 返回当前日期和时间 SELECT now(); 2020-04-03 15:54:33 Second 返回某个日期的秒 SELECT second(‘2020-04-03 15:54:33’); 33 Time 返回时间部分 SELECT Time(‘2020-04-03 15:54:33’); 15:54:33 Year 返回某个日期的年份 SELECT Year(‘2020-04-03 15:54:33’); 2020 我们看一些具体例子。 首选日期格式 yyyy-mm-dd; 给出完整的4位数字年份更加可靠； 12345678910111213141516171819202122SELECT cust_id,order_numFROM ordersWHERE order_date = '2005-09-01';+---------+-----------+| cust_id | order_num |+---------+-----------+| 10001 | 20005 |+---------+-----------+-- 我们看看整个表长成什么样子SELECT * FROM orders;+-----------+---------------------+---------+| order_num | order_date | cust_id |+-----------+---------------------+---------+| 20005 | 2005-09-01 00:00:00 | 10001 || 20006 | 2005-09-12 00:00:00 | 10003 || 20007 | 2005-09-30 00:00:00 | 10004 || 20008 | 2005-10-03 00:00:00 | 10005 || 20009 | 2005-10-08 00:00:00 | 10001 |+-----------+---------------------+---------+ 我们可以发现order_date为2005-09-01虽然被找出来了，但是一旦有时间的信息，比如2005-09-01 11:30:05则匹配失败，我们也不可能记得如此精确地时间进行检索，所以通常我们会比较列中日期的一部分，为此，可以用Date函数进行日期的比较。 123456789SELECT cust_id,order_numFROM ordersWhere Date(order_date) = '2005-09-01';+---------+-----------+| cust_id | order_num |+---------+-----------+| 10001 | 20005 |+---------+-----------+ 另一种场景是当我们想要获得9月份所有的订单信息，可以比较年份和月份，也可以指定日期范围。  1234567891011121314151617SELECT cust_id,order_numFrom ordersWHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';-- 也可以如下，结果相同SELECT cust_id,order_numFrom ordersWHERE Year(order_date)=2005 AND Month(order_date)=9;+---------+-----------+| cust_id | order_num |+---------+-----------+| 10001 | 20005 || 10003 | 20006 || 10004 | 20007 |+---------+-----------+ 11.1.3 数值处理函数常见的代数，三角函数，几何运算。 Abs, Cos, Exp, Mod, Pi, Rand, Sin, Sqrt, Tan估计看名字也就知道意思了。 1234567SELECT Sin(Pi());+------------------------+| Sin(Pi()) |+------------------------+| 1.2246467991473532e-16 |+------------------------+ 第十二章 汇总数据本章介绍什么是SQL的聚集函数以及如何利用他们汇总表的数据。 12.1 聚集函数我们通常需要汇总数据而不是直接将他们检索出来。有如下几个方面的例子，例如 确定表中的行数，例如9月份订单总数 确定行的和，比如9月份消费总金额 找出列中的最大值，最小值，平均值等 聚集函数（aggregate function）运行在行组上，计算和返回单个值的函数。 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 12.2 常见聚集函数的示例12.2.1 AVG均值函数12345678910111213141516171819202122SELECT AVG(prod_price) AS avg_priceFROM products;-- prod_price这列所有行的平均值+-----------+| avg_price |+-----------+| 16.133571 |+-----------+SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;-- prod_price这列，满足vend_id=1003的所有行的平均值+-----------+| avg_price |+-----------+| 13.212857 |+-----------+ 注意： avg只能用于一列的计算，如果要计算多列，则需要多个avg语句； avg会忽略值为NULL的行。 12.2.2 COUNT计数函数返回表中行的数目，或者满足条件的行的数目。 COUNT(*)对表中行的数目进行技术，不管表列中包含的是空值还是非空值； 使用COUNT(column)对特定的列中具有值的行进行技术，忽略NULL值。 123456789101112131415161718192021SELECT COUNT(*) AS num_custFROM customers;-- 表customers总共具有5行数据+----------+| num_cust |+----------+| 5 |+----------+SELECT COUNT(cust_email) AS num_custFROM customers;-- 只有3行具有email地址的顾客，有两行email地址为NULL+----------+| num_cust |+----------+| 3 |+----------+ 12.2.3 MAX，MIN最值函数返回指定列中的最大值,忽略NULL。 12345678SELECT MAX(prod_price) AS max_priceFROM products;+-----------+| max_price |+-----------+| 55.00 |+-----------+ 12.2.4 SUM求和函数用法类似于求均值，只是不用除以求和的总个数了。 12.3 聚集函数的其他用法对以上5个聚集函数在使用时， 对所有的行执行计算，指定ALL参数或者不给参数（默认ALL） 只包含不同的值，指定DISTINCT参数 123456789SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;-- 上节中未加DISTINCT,均值为13.212857，现在加入DISTINCT,我们只算不同的值的平均数，二者有了差别。+-----------+| avg_price |+-----------+| 15.998000 | SELECT语句可包含多个聚集函数 1234567891011SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM products;+-----------+-----------+-----------+-----------+| num_items | price_min | price_max | price_avg |+-----------+-----------+-----------+-----------+| 14 | 2.50 | 55.00 | 16.133571 |+-----------+-----------+-----------+-----------+ 第十三章 分组数据本章介绍如何分组数据，以便能汇总表内容的子集，这涉及两个新SELECT语句子句，分别是GROUP BY和HAVING子句。 123456789101112131415161718192021222324252627SELECT COUNT(*) AS num_prodsFROM productsWHERE vend_id =1003;+-----------+| num_prods |+-----------+| 7 |+-----------+-- 这里我们返回了供应商1003提供的商品数目，但是如果我们想知道每个供应商提供的商品数目怎么办？-- 难道找出所有的vend_id, 然后逐个按照上面的代码查询吗？显然比较麻烦，这个时候就需要分组数据了。SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id;+---------+-----------+| vend_id | num_prods |+---------+-----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+-----------+-- 按照vend_id分组，然后对每组使用聚集函数 Group by 可以包含任意数目的列，这使得能对分组进行嵌套，实施更加精细的分组； 在建立分组时，Group by后面的所有都参与分组，只要有一个列取值不同，就可以作为一个分组； Group by后面的列必须是有效的表达式，不能是聚集函数，若在select中使用表达式，则group by中使用相同的表达式，不能使用别名； 1select vend_id, vend_id*prod_price as alias from products group by vend_id,alias; 除聚集语句外，在select后面的所有列都必须出现在group by中； 12select vend_id from products group by prod_price; -- 错误select vend_id from products group by vend_id; -- 成功 如果分组具有NULL值，则所有具有NULL值的行将作为一组； Group by子句出现在WHERE之后，ORDER BY之前。 12345678910111213141516171819202122SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP;-- 有with rollup的结果,对分组结果进行汇总，比如总共有14个num_prods,即列和为14+---------+-----------+| vend_id | num_prods |+---------+-----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 || NULL | 14 |+---------+-----------+-- 没有with rollup的结果+---------+-----------+| vend_id | num_prods |+---------+-----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+-----------+ 13.1 过滤分组假设我们想要知道在orders表中，每位顾客的订单数，只需要按顾客编号进行分组，然后用count计数即可。但如果我们的需求是找出买了至少两个东西的顾客呢，此时分组就不够了，我们还要对分组进行过滤，找出计数数不小于2的分组，此时用HAVING子句。 12345678910SELECT cust_id,COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2;-- 以下输出结果表明只有编号为10001的顾客下了至少两个单+---------+--------+| cust_id | orders |+---------+--------+| 10001 | 2 |+---------+--------+ 13.1.1 HAVING与WHERE的差别在之前章节中，HAVING完全可以替代WHERE. 12345678SELECT cust_id FROM orders HAVING cust_id = 10001;-- 此处和WHERE相同+---------+| cust_id |+---------+| 10001 || 10001 |+---------+ 但是，HAVING可以用在分组处理中，而where是对所有的行进行过滤。 另外一种理解方式，就是where首先对数据进行过滤，排除不需要的行，然后group by对剩下的行进行分组，最后是having进行分组过滤。来看如下例子： 123456789101112131415161718192021222324252627282930SELECT vend_id,COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;=10GROUP BY vend_idHAVING count(*) &gt;=2;-- 用where过滤了，所以行数变少了，相应地能够达到超过两行的数目也就变少了+---------+-----------+| vend_id | num_prods |+---------+-----------+| 1003 | 4 || 1005 | 2 |+---------+-----------+SELECT vend_id,COUNT(*) AS num_prodsFROM productsGROUP BY vend_idHAVING count(*) &gt;=2;-- 1002供应商也有两个产品，但是价格都低于10，因此在上个代码输出中不会出现1002+---------+-----------+| vend_id | num_prods |+---------+-----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+-----------+ 13.2 分组和排序分组Group by是分组行，但输出不一定是什么顺序, 排序Order by是排序产生的输出。我们有时候在分组汇总之后，还要对分组的顺序加以限定，于是就出现了分组和排序的组合。 12345678910111213141516171819202122232425262728SELECT order_num,SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price)&gt;=50;+-----------+------------+| order_num | ordertotal |+-----------+------------+| 20005 | 149.87 || 20006 | 55.00 || 20007 | 1000.00 || 20008 | 125.00 |+-----------+------------+SELECT order_num,SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price)&gt;=50ORDER BY ordertotal;-- 指定按照ordertotal排序+-----------+------------+| order_num | ordertotal |+-----------+------------+| 20006 | 55.00 || 20008 | 125.00 || 20005 | 149.87 || 20007 | 1000.00 |+-----------+------------+ 13.3 SELECT子句顺序 子句 说明 是否必须 SELECT 选择列或表达式 是 FROM 从表 仅在从表中选择数据时使用 WHERE 行过滤 否 GROUP BY 分组 仅在按组计算聚集时使用 HAVING 按组过滤 否 ORDER BY 对输出排序 否 LIMIT 限制检索行数 否]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>计算</tag>
        <tag>汇总</tag>
        <tag>分组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL过滤搜索操作]]></title>
    <url>%2F2020%2F04%2F01%2FMySQL%E8%BF%87%E6%BB%A4%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[[TOC] 本文主要介绍MySQL基本的过滤和搜索服务, 包括where子句的过滤操作，in, not in的操作符。更精确地，可以采用like,或者regexp写正则表达式进行匹配。 第六章 过滤数据想象一下，我们现在有一个学生信息的表，学校要求开展关于少数民族的活动，我们想知道班级里有多少人是少数民族，于是我们需要抽取出民族非汉的所有学生，此时我们利用之前学习的检索是做不到的，这也就是我们接下来要介绍的过滤和搜索服务。 WHERE子句是执行过滤操作的关键字。 口令 用途 备注 SELECT prod_name,prod_price FROM products WHERE prod_price = 2.5; 过滤出prod_price为2.5的列 相等的过滤 =；&lt;&gt;(不等) ; !=(不等) ; &lt; ; &gt; ; &lt;= ; &gt;= ; BETWEEN a AND b 不同的where子句的操作符 BETWEEN的格式注意一下 SELECT prod_name,prod_price FROM products WHERE prod_name = “fuses”; 字符串相等 不区分大小写，也会匹配Fuses SELECT prod_name,prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; prod_price在5-10之间 包括两个端点处的值 SELECT prod_name FROM products WHERE prod_price IS NULL; 空值检查 注意0,空字符串，空格等都不属于空值 空值的场景，假设是在搜集估计的信息，可能有些顾客不愿意或者没有提供电子邮件或者电话号码，则会出现空值，我们通常会在创建数据库时指定某列是否允许空值。 注意：用其他的过滤条件不会找出具有NULL值的行，因为NULL与其他条件不匹配。 第七章 数据过滤WHERE子句允许逻辑操作符，不同的WHERE子句用AND或OR进行连接。 口令 用途 备注 SELECT prod_id,prod_name,prod_price FROM products WHERE vend_id=1003 AND prod_price &lt;= 10; AND逻辑操作符，与 集合中的交集操作 SELECT prod_name,prod_price FROM products WHERE vend_id =1002 OR vend_id =1003; OR逻辑操作符，或 集合中的并集操作 SELECT prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name; IN指定条件范围，括号内所有值可以进行匹配，以逗号分隔 和OR起到的作用一致 SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN (1002,1003) ORDER BY prod_name; NOT用来否定条件 注意: 多使用圆括号操作符改变顺序，不然默认的计算次序AND &gt; OR，有时会不经意间产生错误。所以我们建议多多使用圆括号； IN比OR更清楚直观，执行速度更快； NOT可以用来否定IN, BETWEEN, EXISTS等，注意这只在MySQL。 第八章 用通配符进行过滤本章介绍如何使用通配符进行复杂过滤。 8.1 什么是通配符当我们想要获取学生中姓高的学生信息的时候，用之前的检索和过滤操作符就不适用了，因为之前的操作符都是等价匹配，而不会有学生的姓名刚好只有高一个字，而会像高一，高二等，所以我们这章就是利用高来匹配高一高二，这就是通配符或者正则表达式。 通配符（wildcard）是用来匹配值的一部分的特殊字符。 搜索模式（search pattern）由字面值，通配符或者两者组合构成的搜索条件。 8.2 通配符种类通配符本身就是WHERE子句中具有特殊含义的字符，为了使用通配符，需要使用LIKE操作符。这里还有一个谓词的概念，当某个操作符的返回值是TRUE,FALSE,UNKNOWN等时，操作符为谓词。 口令 用途 备注 SELECT prod_id,prod_name FROM products WHERE prod_name LIKE ‘jet%’; %用于任何字符出现任意次数，找出所有以jet开头的prod_name 当然也可以0次 SELECT prod_id,prod_name FROM products WHERE prod_name LIKE ‘%anvil%’; 可以使用多个通配符，anvil在中间的prod_name 因为可以是0次，所以开头或结尾都行 SELECT prod_id,prod_name FROM products WHERE prod_name LIKE ‘s%e’; 以s开头，e结尾的字符 SELECT prodid,prod_name FROM products WHERE prod_name LIKE ‘ ton anvil’; 下划线匹配一个字符 注意：%不能匹配NULL值； 8.3 使用通配符的技巧当我们使用通配符时，需要了解： 通配符搜索花掉的时间更多； 先使用其他操作符，再使用通配符效率会更高； 统配符的位置不要放错。 第九章 用正则表达式进行搜索正则表达式是用来匹配文本的特殊的集合，比如从文本文件中提取电话号码，邮箱等。MySQL仅支持多数正则表达式的一个很小的子集。 口令 用途 备注 SELECT prod_name FROM products WHERE prod_name REGEXP “1000” ORDER BY prod_name; 检索prod_name包含文本1000的所有行 他是在列值内进行匹配，如果能找到1000，则匹配成功，相当于操作对象为某列某行的字符串；而LIKE则是匹配整个列，而不是看列值是否包含。 SELECT prod_name FROM products WHERE prod_name REGEXP “.000” ORDER BY prod_name; .表示匹配任意一个字符 如果想要区分大小写，可以在REGEXP后加入BINARY SELECT prod_name FROM products WHERE prod_name REGEXP “1000\ 2000” ORDER BY prod_name; \ 表示或者的关系 匹配1000或者2000 SELECT prod_name FROM products WHERE prod_name REGEXP “[123] ton”ORDER BY prod_name; [123]表示匹配方括号内任一个字符 []和\ 作用类似 SELECT prod_name FROM products WHERE prod_name REGEXP “[\^123] ton”ORDER BY prod_name; ^表示不匹配123之一，起否定作用 文本中有反斜杠，其实不对，应该扔掉，是因为在Markdown中，如果不加反斜杠的话，^会被解释为脚注，只是格式问题 SELECT prod_name FROM products WHERE prod_name REGEXP “[1-5] ton”ORDER BY prod_name; [1-5]匹配1，2，3，4，5任一字符 [a-z] SELECT prod_name FROM products WHERE prod_name REGEXP “\\.“ORDER BY prod_name; 匹配特殊字符. 用两个转义字符\\匹配特殊字符 假如相匹配 1 ton, 2 ton 或者 3 ton，则需要用”[123] ton”,或者”[1|2|3] ton”，就是不能使用 1|2|3 ton，他会默认是1或者2或者3 ton，从而检索出错。 \\f匹配换页，\\n匹配换行，\\r匹配回车，\\t匹配制表，\\v匹配纵向制表 9.1 MySQL的字符类MySQL具有很多预定义的字符集，称为字符类： 9.2 匹配多个实例当你想要匹配一个电话号码的时候，需要匹配11个数字，但如果写出[0-9]重复11次，则显得非常冗余，有没有什么方式可以指定匹配11个数字呢，我们有如下的特殊字符。 元字符 说明 * 匹配任意长度字符，可以为0 + 至少一个字符 ？ 0个或1个 {n} n个 {n,} 至少n个 {n,m} n-m个，m不超过255 ^ 文本的开始（在[]内部作否定使用） $ 文本的结尾 [[:&lt;:]] 词的开始(没有试验成功，不知使用方法) [[:&gt;:]] 词的结尾 下面我们给出一些示例。 口令 用途 备注 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\\([0-9] sticks?\\)‘ ORDER BY prod_name; \\(\\)使得匹配圆括号；sticks?使得s可有可无 SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}’ ORDER BY prod_name; [:digit:]代表任意数字，{4}代表4次 [:digit:]可以想象成0-9 SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\\.]’ ORDER BY prod_name; 以数字或者.开头的匹配 SELECT “hello” REGEXP ‘[0-9]’; 返回0 在不调用数据库情况下测试正则表达式]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>过滤，搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql基本检索语句]]></title>
    <url>%2F2020%2F03%2F31%2FMySql%E5%9F%BA%E6%9C%AC%E6%A3%80%E7%B4%A2%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[[TOC] 本文主要介绍什么是SQL语句，什么是MySQL，以及他们之间的差别，如何开始用MySQL书写SQL语句操作数据库。SELECT, ORDER BY进行基本的检索和排序操作。 第一章 了解SQL1.1 数据库基础 名称（英文名） 定义 备注 数据库（database） 一个以某种有组织的方式存储的数据集合 可以把它想象成一个文件柜 数据库管理系统（DBMS-Database Management system） 也可以称之为数据库软件，它替我们访问数据库。 例如mysql,oracle 表（table） 某种特定类型数据的结构化清单 就像excel中的表一样，可以用来存储学生名单等。同一数据库下不能有相同名称的表 模式（schema） 关于数据库和表的布局及特性的信息 定义了数据在表中如何存储，存什么样的数据，列的分解，命名信息 列（column） 表中的一个字段 可以认为是一个变量的取值，如学生姓名 行（row） 表中的一个记录 某一个学生所有的信息，姓名，学号，地址，成绩的一条记录 数据类型（datatype） 所容许的数据的类型 数值型，日期，文本，注释等，合适的数据类型可以用来正确排序，优化磁盘（节省存储空间）。 主键（primary key） 表中的每一行都应该有可以唯一标识自己的一列（或一组列） 比如用学生的学号就不会重复，但是如果用学生的性别，那很多人都会重复，这样的列是不可以作为主键的 注意：表中任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值）。 1.2 什么是SQLSQL（发音为S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写，是用来与数据库通信的语言。 SQL由很少的词组成，是为了让从数据库中读写数据变得容易； 几乎所有的DBMS都支持SQL，所以了解SQL可以和任何数据库打交道； 1.3 开始之前开始学习数据库之前，你应当准备好一下内容： 安装mysql 根据脚本创建必要的数据库和表，从而可以试验每个样例。 第二章 MySQL简介2.1 什么是MySQLMySQL是一种特殊的数据库管理软件（DBMS），它开源免费，简单易上手，性能很好，值得信赖。 名称 定义 举例 特点 一类DBMS 基于共享文件系统 Microsoft Access和FileMaker 用于桌面用途，通常不用于高端或更关键的应用 另一类DBMS 基于客户机-服务器 MySQL,Oracle,Microsoft SQL Server 服务器部分是负责所有数据访问和处理的一个软件，运行在称为数据库服务器的计算机上；而数据添加，修改，删除等命令的提交请求都是有客户机软件下达的。然后由服务器处理后把结果返回给客户机 MySQL客户机选择 命令行；MySQL Administrator; MySQL Query Browser 第三章 使用MySQL为了使用MySQL, 需要以下信息： 主机名，本地为localhost 端口，默认3306 用户名 用户密码 口令 用途 备注 CREATE DATABASE learning; 创建数据库，名为learning USE learning; 选择使用数据库learning 接下来表的操作都会在当前数据库下进行 SHOW DATABASES; 显示数据库的信息，存储在MySQL（是数据库的名字）中 默认有mysql,sys等内部使用的数据库 SHOW TABLES; 显示当前数据库下表的信息 SHOW COLUMNS FROM customers;（DESCRIBE customers） 显示learning数据库下customers表中所有的列的信息 列的信息包括名称，类型，是否允许NULL值 SHOW STATUS; 用于显示服务器状态信息 SHOW CREATE DATABASE mysql;SHOW CREATE TABLE; 显示创建特定数据库或表的信息 SHOW GRANTS; 显示用户的安全权限，比如可以执行的操作命令 SHOW ERRORS;SHOW WARNNINGS; 显示错误或警告信息 注意事项： 自动增量, MySQL可以自动为每个行分配下一个可用编号，不用手动添加； 如果忘记了命令，可以使用help语句，比如help show可以查看可用的show命令； SQL语句是不区分大小写的，之所以把关键字写成大写字母，主要是为了方便阅读和调试； SQL语句以分号结尾； SQL会忽略所有的空格，所以分行书写命令会更加容易阅读。 第四章 检索数据通常，数据库很大，如果我们直接把数据库中整个的表获取到我们本地计算机，则很有可能会因为内存不足而失败。所以，往往我们只需要从数据库中提取部分需要的信息即可，而SELECT语句就是起到了这个作用。 SELECT语句的基本格式就是从哪里检索什么东西？ 4.1 获取列 口令 用途 备注 SELECT prod_name FROM products; 从某个表products获取列prod_name 返回是未排序的数据，不同机器可能显示不同 SELECT prod_id,prod_name,prod_price FROM products; 获取三个列 列名之间用逗号分开 SELECT *FROM products; 选取所有列 *是通配符，检索不需要的列通常会降低检索和应用程序的性能 我们也可以用完全限定的表明，在之前我们只是指明了列名，也可以使用数据库+表名或者表+列名来进行限定。 1234567891011121314151617181920SELECT products.prod_name FROM learning.products；+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed || Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+ 4.2 获取行如下所示，当我们选取某个列时，所有的行都会被显示出来，这样就有可能会出现大量的重复值。例如我们想看看有哪些供应商，则我们不需要看到1000个写着1001的行，这样就不能看到直观的结果。 口令 用途 备注 SELECT DISTINCT vend_id FROM products; 返回不同值的行 DISTINCT放在列名的前面，他应用所有的列。比如指定姓名和学校，则gao,peking 和 shang,peking将会被显示 SELECT prod_name FROM products LIMIT 5； 返回不超过5行 之所以写成不超过是因为如果没有足够的行，所只返回仅有的行 SELECT prod_name FROM products LIMIT 2, 5（等价于 LIMIT 5 OFFSET 2）； 从第二行开始，返回最多5行检索数据 索引从0开始，即第一行实际上是行0 第五章 排序检索数据当检索出来数据的时候，我们总是期望按照某种方式进行排序，比如学号从小到大，成绩由高到低。 ORDER BY子句默认按照升序排序。 口令 用途 备注 SELECT prod_name FROM products ORDER BY prod_name; 按照prod_name排序 可以按照未被检索的列进行排序，例如ORDER BY prod_price. SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price,prod_name; 按照多个列进行排序 先按照prod_price排序，再按prod_name排序 SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC; 按照降序排序 Descending SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC, prod_name DESC; 按照多个列降序排列，必须为每个列指定，否则未指定的列依然是升序]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>检索</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十七章 含参变量积分]]></title>
    <url>%2F2019%2F12%2F26%2F%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%90%AB%E5%8F%82%E5%8F%98%E9%87%8F%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[含参变量积分 换序的条件； 一致收敛性判断； 三种常见的求含参变量积分的方式。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>换序</tag>
        <tag>含参变量积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六章 曲线和曲面积分]]></title>
    <url>%2F2019%2F12%2F12%2F%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[曲线曲面积分 曲线，曲面的参数方程； 新坐标系的建立 积分区域的对称性； gauss-green公式，分部积分公式与平均值公式。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>曲线积分</tag>
        <tag>曲面积分</tag>
        <tag>gauss-green公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五章 重积分和反常积分]]></title>
    <url>%2F2019%2F11%2F28%2F%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%87%8D%E7%A7%AF%E5%88%86%E5%92%8C%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[重积分与反常积分 复合函数可积性的证明； 反常积分收敛的判别法则； 常用的证明收敛与发散的方法； 掌握常用的积分区域与参数方程写法。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>反常积分</tag>
        <tag>复合函数可积性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见积分区域的三维图形]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%B8%B8%E8%A7%81%E7%A7%AF%E5%88%86%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[掌握常见的积分区域]]></content>
      <tags>
        <tag>积分区域</tag>
        <tag>mathematica</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[期中考试-伍]]></title>
    <url>%2F2019%2F11%2F17%2F%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95-%E4%BC%8D%2F</url>
    <content type="text"><![CDATA[期中试卷]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>wu</tag>
        <tag>期中考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五章 重积分]]></title>
    <url>%2F2019%2F11%2F15%2F%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%87%8D%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[重积分 重积分的定义； 可积性条件； 计算-化成累次积分，变量替换。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>可积性</tag>
        <tag>重积分定义</tag>
        <tag>累次积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二次作业解答]]></title>
    <url>%2F2019%2F10%2F31%2F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E7%AD%94-md%2F</url>
    <content type="text"><![CDATA[感谢何波澔同学的作业]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>第二次作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章5-6节部分.md]]></title>
    <url>%2F2019%2F10%2F31%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A05-6%E8%8A%82%E9%83%A8%E5%88%86-md%2F</url>
    <content type="text"><![CDATA[隐函数，极值与几何应用 隐函数存在定理，反函数存在定理； 极值与条件极值； 几何应用；]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>隐函数</tag>
        <tag>极值</tag>
        <tag>几何应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[往年期中考试试题]]></title>
    <url>%2F2019%2F10%2F18%2F%E5%BE%80%E5%B9%B4%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[期中考试 开集，闭集与连续性的相关问题； 单变量连续与全变量连续； 凸函数的定义与性质； 极值问题； 隐函数存在定理。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>往年题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章 多元微分学第二部分]]></title>
    <url>%2F2019%2F10%2F18%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A02-3-4%E8%8A%82%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[多元微分学 高阶偏导数； 偏导数换序问题。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>高阶导数，偏导数换序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章 多元微分学第一部分]]></title>
    <url>%2F2019%2F10%2F18%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A02-3-4%E8%8A%82%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[多元微分学 方向导数，偏导数，梯度，可微的定义； 可微与偏导数存在，连续之间的关系； 凸域中的问题；]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>偏导数，方向导数，梯度，全微分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三章 多元函数的极限和连续]]></title>
    <url>%2F2019%2F09%2F19%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[高维欧式空间基本内容 1.1 开集，闭集，聚点，边界点，闭包定义； 1.2 极限与累次极限； 1.3 函数的连续性和一致连续性。 极限与连续性 2.1 开集和闭集在连续映射下的像与原像问题； 2.2 道路连通集在连续映射下的像与原像问题； 2.3 全连续与单变量连续的关系，在何种条件下可以互推； 2.4 连续函数和一致连续函数类似于一元函数情形的性质。]]></content>
      <categories>
        <category>数学分析3</category>
      </categories>
      <tags>
        <tag>极限</tag>
        <tag>累次极限</tag>
        <tag>连续</tag>
        <tag>一致连续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总复习]]></title>
    <url>%2F2019%2F06%2F09%2F%E6%80%BB%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[总复习 查漏补缺 裴礼文习题集部分题目]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第十二章 Fourier级数展开]]></title>
    <url>%2F2019%2F05%2F29%2FFourier%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[Fourier级数 展开的意义，系数在有限维空间中的对应关系 误差标准—-平方平均误差 收敛性判定的依据 parseval等式，Bessel不等式 一致收敛性]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>Fourier级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 连续函数的多项式逼近]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%80%BC%E8%BF%91%2F</url>
    <content type="text"><![CDATA[连续函数的多项式逼近 visser定理 概率论的证明方式——二项分布 光滑化的想法]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>逼近</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 幂级数展开]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%B9%82%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[幂级数展开 导数容易展开的情况，例arcsin,arctan 基本函数组合而成的形式，例e^x, ln(1+x), sin(x), cos(x), (1+x)^a 乘积形式的——(ln(1-x))^2 可以参考裴礼文习题集对这个问题的总结！]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>Taylor展开式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 幂级数收敛半径与收敛域]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%B9%82%E7%BA%A7%E6%95%B0%E6%94%B6%E6%95%9B%E5%8D%8A%E5%BE%84%E4%B8%8E%E6%94%B6%E6%95%9B%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[幂级数 收敛半径和收敛域 和函数 $sin(n!\pi x)$的收敛域的特殊情况]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>幂级数，收敛域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数序列与函数项级数的换序问题]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%87%BD%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%8E%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E6%8D%A2%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[换序问题 连续性换序 积分换序 求导换序]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>换序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析2 函数项级数的一致收敛性]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E6%80%A7%2F</url>
    <content type="text"><![CDATA[函数序列的一致收敛性—最值判别法 函数项级数的一致收敛性——魏尔斯特拉斯定理，柯西收敛准则等]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>函数项级数，一致收敛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析2 期中试题解析]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E6%9C%9F%E4%B8%AD%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本次考试中： 第1题 利用导函数和其他函数的差异：介值定理 第2题 见数分讲义2017年 第3题 见数分讲义2019年3月13日 第4题 见数分讲义2019年3月13日 第5题 见数分讲义2019年4月3日 第6题 见数分讲义2019年4月10日 第7题 见数分讲义2019年3月27日 第8题 见数分讲义2019年4月10日 第9题 方法同讲义2019年4月10日 第10题 课本无穷乘积]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>数学分析2，期中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章 数项级数综合与复习]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%BB%BC%E5%90%88%E4%B8%8E%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[往年真题回顾 级数收敛性的判断 2.1 判断级数的敛散性和绝对敛散性 2.2 类Dirichlet和Abel判别法的判别法推导]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>数项级数，真题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章 正项级数和任意项级数]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E6%AD%A3%E9%A1%B9%E7%BA%A7%E6%95%B0%E5%92%8C%E4%BB%BB%E6%84%8F%E9%A1%B9%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第八章遗漏的题目。 正项级数和任意项级数的敛散性。]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>正项级数，任意项级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章 广义积分收敛性]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E6%94%B6%E6%95%9B%E6%80%A7%2F</url>
    <content type="text"><![CDATA[广义积分敛散性和绝对收敛性。 无穷积分收敛性与无穷远处极限为0的关系。]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>广义积分， 无穷远处极限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七八章 定积分综合及广义积分初步]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%BB%BC%E5%90%88%E5%8F%8A%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[有限区间定积分综合 周期相关问题； 无穷范数问题； 区间变化； 零点问题。 广义积分 广义积分敛散性的判断11条。 ​ ​]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>周期性，范数，区间变换，零点问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 中值定理和定积分的应用]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E7%AC%AC%E4%B8%83%E7%AB%A07-5-7-6%E8%8A%82%2F</url>
    <content type="text"><![CDATA[中值定理 积分第一中值定理； 积分第二中值定理； 带积分余项的Taylor公式。 定积分的应用 young不等式； 会求曲线长度，旋转体体积和平面图形面积等。]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>中值定理，几何应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 变限积分和定积分的计算]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E7%AC%AC%E4%B8%83%E7%AB%A07-4%E8%8A%82%2F</url>
    <content type="text"><![CDATA[变限定积分 变上限积分的连续性和可微性与被积函数的可积性与连续性的关系； 原函数存在与函数可积性的关系； 变限定积分的求导和极限的问题。 积分的极限和极限的积分 不能直接换序，除非首先证明。 定积分的计算 换元法； 分部积分；]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>变限积分</tag>
        <tag>极限与积分换序</tag>
        <tag>Cauchy-Schwarz不等式</tag>
        <tag>分离变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 定积分概念，可积性与性质]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%902-%E7%AC%AC%E4%B8%83%E7%AB%A07-1-7-2-7-3%E8%8A%82%2F</url>
    <content type="text"><![CDATA[积分的定义方式（==了解即可==） 1.1 现有的积分—Riemann积分，Lesbesgue积分，随机积分等； 1.2 端点选取的影响，左端点，右端点，中点等； 1.3 积分收敛的意义。 Riemann积分的可积性 2.1 可积的必要条件； 2.2 可积的两个个等价条件； 2.3 Lebesgue定理（几乎处处连续）。（==了解即可-适当补充测度论的概念==） 利用积分求数列极限 积分的性质 4.1 线性性质； 4.2 分段积分； 4.3 不等式：绝对值，凸函数，柯西-施瓦茨不等式； 4.4 函数的逼近（典型方法）—（==十分重要==）。]]></content>
      <categories>
        <category>数学分析2</category>
      </categories>
      <tags>
        <tag>定积分</tag>
        <tag>可积性</tag>
        <tag>典型方法</tag>
      </tags>
  </entry>
</search>
